#ifndef BINAVERAGE_H
#define BINAVERAGE_H

#ifndef FuncName
//#define FuncName __PRETTY_FUNCTION__
#define FuncName __FUNCTION__
//#define FuncName __func__
#endif

#include "DataTypes.h"
#include <stdexcept>

/* exceptions */
namespace ErrorBA {

   class Base : public std::runtime_error {
   public:
      Base(const std::string message)
         : runtime_error(message) {
			PrintStacktrace();
      }
   };

	class EmptyData : public Base {
	public:
		EmptyData(const std::string funcname, const std::string info = "")
			: Base("Error("+funcname+"): Empty data input ("+info+").") {}
	};

}


template < class T >
class BinAverage {
public:

	BinAverage( const std::vector<T>& datain ) {
		reset( datain );
	}

	void reset( const std::vector<T>& datain ) {
		_data = datain;
      if( _data.size() == 0 ) throw ErrorBA::EmptyData(FuncName);
	}

	void reset( std::vector<T>&& datain ) {
		_data = std::move(datain);
      if( _data.size() == 0 ) throw ErrorBA::EmptyData(FuncName);
	}


protected:
   static constexpr float NaN = AziData::NaN;

private:
	std::vector<T> _data;

	void BinAverage1( const float per, const float binstep, const float binhwidth,
							std::vector<AziData>& result, std::vector<StaData>& dataV, std::string& sDValid=sTrash ) const {

		// transfer the (Sta)data into a new vector of (Sta)data with boundaries extended (periodically)
		dataV.clear();
		const float binwidth = binhwidth * 2;
		PeriodicExtension( datao, binwidth, dataV);

		// bin average the data vector (use center azimuth for the azi of each bin)
		BinAvg( dataV, binstep, binhwidth, per, result, false );

		// exclude 'bad' data based on the bin-average from 1st iteration
		ExcludeBad_Bin( dataV, result, binhwidth, sDValid );
	}
};


#endif
